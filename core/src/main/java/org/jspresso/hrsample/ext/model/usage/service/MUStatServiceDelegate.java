package org.jspresso.hrsample.ext.model.usage.service;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;

import javax.sql.DataSource;

import org.jboss.logging.Logger;
import org.jspresso.framework.model.component.service.IComponentService;
import org.jspresso.framework.model.entity.IEntityFactory;
import org.jspresso.hrsample.ext.model.usage.MUItem;
import org.jspresso.hrsample.ext.model.usage.MUModule;
import org.jspresso.hrsample.ext.model.usage.MUStat;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowCallbackHandler;

/**
 * Generated by Jspresso Developer Studio
 */
public class MUStatServiceDelegate implements IComponentService {

  private JdbcTemplate jdbcTemplate;
  private IEntityFactory entityFactory;
  
  private static final String SQL_COUNT_BASE = 
      "SELECT COUNT(DISTINCT ACCESS_BY), COUNT(*) \n" + 
      "  FROM MODULE_USAGE \n" + 
      " WHERE ACCESS_DATE > ?";
  
  private static final String SQL_COUNT_USERS_PER_MODULES = 
      "SELECT MODULE_ID, COUNT(DISTINCT ACCESS_BY) \n" + 
      "FROM MODULE_USAGE \n" + 
      "WHERE ACCESS_DATE > ? \n" + 
      "GROUP BY MODULE_ID \n " +
      "ORDER BY MODULE_ID";
  
  private static final String SQL_COUNT_ACCESS_PER_MODULES = 
      "SELECT MODULE_ID, COUNT(*) \n" + 
      "  FROM MODULE_USAGE \n" + 
      " WHERE ACCESS_DATE > ? \n" + 
      " GROUP BY MODULE_ID \n" +
      " ORDER BY MODULE_ID";  
  
  //(select DISTINCT CONCAT(DATE_FORMAT(m.ACCESS_DATE,'%Y'),'-',DATE_FORMAT(m.ACCESS_DATE,'%u')) AS period,
  
  private static final String SQL_COUNT_ACCESS_PER_PERIOD_FOR_MODULE = 
      "SELECT dd, COUNT(*) \n" + 
      "FROM MODULE_USAGE mu, \n" + 
      "   (select DISTINCT (--PERIOD--), m.ID, m.ACCESS_DATE as dd \n" + 
      "      from MODULE_USAGE m \n" + 
      "     where m.ACCESS_DATE > ?) mu2 \n" + 
      "WHERE mu.ID = mu2.ID \n" + 
      "AND mu.MODULE_ID = ? \n" +
      "GROUP BY dd \n" + 
      "ORDER BY dd DESC";
  
  /**
   * Configures the datasource .
   * @param dataSource
   */
  public void setDataSource(DataSource dataSource) {
    jdbcTemplate = new JdbcTemplate(dataSource);
  }
  
  /**
   * set the entityfactory to use
   * @param entityFactory
   */
  public void setEntityFactory(IEntityFactory entityFactory) {
    this.entityFactory = entityFactory;
  }
  
  /**
   * refresh data using datasource
   */
  public void refresh(final MUStat muStat) {
    
    Logger.getLogger(getClass()).debug("Refreshing stats");
    
    // global counters
    Object[] restrictionsValues = new Object[] {getStartDate(muStat)};
    int[] restrictionsTypes = new int[] {Types.DATE};
    jdbcTemplate.query(SQL_COUNT_BASE, restrictionsValues, restrictionsTypes,
        new RowCallbackHandler() {
          @Override
          public void processRow(ResultSet rs) throws SQLException {
            muStat.setUsersCount(rs.getInt(1));
            muStat.setAccessCount(rs.getInt(2));
          }
        });
    
    // users per modules
    final ArrayList<MUItem> items = new ArrayList<MUItem>();
    jdbcTemplate.query(SQL_COUNT_USERS_PER_MODULES, restrictionsValues, restrictionsTypes,
        new RowCallbackHandler() {
          @Override
          public void processRow(ResultSet rs) throws SQLException {
            items.add(getItem(muStat, rs.getString(1), rs.getInt(2)));;
          }
        });
    muStat.setUsersPerModule(items);
    
    // access per modules
    items.clear();
    jdbcTemplate.query(SQL_COUNT_ACCESS_PER_MODULES, restrictionsValues, restrictionsTypes,
        new RowCallbackHandler() {
          @Override
          public void processRow(ResultSet rs) throws SQLException {
            items.add(getItem(muStat, rs.getString(1), rs.getInt(2)));;
          }
        });
    muStat.setAccessPerModule(items);
    
    // access per period for modules
    if (muStat.getHistoryModule() !=null && muStat.getHistoryModule().getModuleId()!=null) {
      items.clear();
      restrictionsValues = new Object[] {getStartDate(muStat), muStat.getHistoryModule().getModuleId()};
      restrictionsTypes = new int[] {Types.DATE, Types.CHAR};
      String query = SQL_COUNT_ACCESS_PER_PERIOD_FOR_MODULE.replaceAll("--PERIOD--", getSQLForPeriod(muStat));
      jdbcTemplate.query(query, restrictionsValues, restrictionsTypes,
          new RowCallbackHandler() {
            @Override
            public void processRow(ResultSet rs) throws SQLException {
              rs.getObject(1);
              items.add(getItem(muStat, formatDateForPeriod(muStat,  rs.getDate(1)), rs.getInt(2)));;
            }
      });
      muStat.setHistoryDetails(items);
    }
    else {
      muStat.setHistoryDetails(null);
    }
  }

  protected MUItem getItem(MUStat muStat, String moduleId, int count) {
    MUModule module = muStat.getModule(moduleId);
    String label = module!=null ? module.getLabel() : moduleId;
    
    MUItem item = entityFactory.createComponentInstance(MUItem.class);
    item.setCount(count);
    item.setLabel(label);
    
    return item;
  }

  private java.sql.Date getStartDate(MUStat muStat) {
    int delta = 0;
    if (MUStat.PERIOD_DAY.equals(muStat.getPeriod())) {
      delta = -1;
    }
    else if (MUStat.PERIOD_WEEK.equals(muStat.getPeriod())) {
      delta = -7;
    }
    else if (MUStat.PERIOD_MONTH.equals(muStat.getPeriod())) {
      delta = -30;
    }
    else {
      delta = -365;
    }
    
    Calendar cal = Calendar.getInstance();
    cal.add(Calendar.DAY_OF_YEAR, delta);

    return new java.sql.Date(cal.getTimeInMillis());
  }
  
  private String getSQLForPeriod(MUStat muStat) {
    if (MUStat.PERIOD_DAY.equals(muStat.getPeriod())) {
      return "DAYS(m.ACCESS_DATE) + '-' + HOUR(m.ACCESS_DATE)";
    }
    else if (MUStat.PERIOD_WEEK.equals(muStat.getPeriod())) {
      return "DAYS(m.ACCESS_DATE) + '-' + HOUR(m.ACCESS_DATE)";
    }
    else if (MUStat.PERIOD_MONTH.equals(muStat.getPeriod())) {
      return "DAYS(m.ACCESS_DATE)";
    }
    else {
      return "DAYS(m.ACCESS_DATE)";
    }
  }

  protected String formatDateForPeriod(MUStat muStat, java.sql.Date sqlDate) {
    Date date = new Date(sqlDate.getTime());
    if (MUStat.PERIOD_DAY.equals(muStat.getPeriod())) {
      return new SimpleDateFormat("HH:mm").format(date);
    }
    else if (MUStat.PERIOD_WEEK.equals(muStat.getPeriod())) {
      return new SimpleDateFormat("EEE").format(date);
    }
    else if (MUStat.PERIOD_MONTH.equals(muStat.getPeriod())) {
      return new SimpleDateFormat("MMM/dd").format(date);
    }
    else {
      return new SimpleDateFormat("MMM").format(date);
    }
  }
  
  /**
   * get module from module id
   * @return module
   */
  public MUModule getModule(MUStat muStat, String moduleId) {
    for (MUModule m : muStat.getAllModules()) {
      if (moduleId.equals(m.getModuleId())) {
        return m;
      }
    }
    return null;
  }
  


}